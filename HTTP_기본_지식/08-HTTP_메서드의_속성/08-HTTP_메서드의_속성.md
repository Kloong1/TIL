# HTTP 메서드의 속성

- 안전 (Safe methods)
- 멱등(Idempotent methods)
- 캐시 가능(Cacheable methods)

![](스크린샷%202022-04-19%20오후%2010.02.35.png)

## 안전 (Safe methods)
- 호출해도 리소스를 변경하지 않는다.
- GET, HEAD 등
- 만약 연속된 GET 요청에 의해 로그가 쌓여서 서버에 장애가 발생한다면?
	- 여기서의 "안전"은 조회하는 리소스만 고려하는 내용이다. 이런 부분은 고려하지 않는 개념.


## 멱등 (Idempotent methods)
- 한 번 호출하든 두 번 호출하든 100번 호출하든, 같은 메서드를 여러번 호출해도 결과가 동일하다.
- f(f(x)) = f(x)
- 멱등한 메서드
	- GET: 여러 번 조회해도 같은 결과가 조회된다.
	- PUT: 클라이언트가 보낸 리소스로 기존 리소스를 완전히 대체한다. 따라서 클라이언트가 동일한 리소스로 계속 PUT request를 해도 항상 결과가 동일하다.
	- DELETE: 리소스를 삭제한다. 동일 리소스에 여러 번 DELETE request를 해도, 해당 리소스가 삭제되었다는 결과는 동일하다.

POST는 멱등이 아니다! 간단히 생각해도 여러 번의 POST request를 통해 프로세스 처리가 여러 번 일어날 수도 있고, 아무튼 멱등을 보장할 수 없다.

멱등이 아닌 메서드는 의도된 동작이 아닌 이상은 여러번 호출하는 경우 문제가 생길 수 있다!

### 활용
예를 들어 자동 복구 메커니즘에 사용될 수 있다.
- 클라이언트가 DELETE request를 했는데, 서버의 응답이 오지 않았다.
- DELETE는 멱등하기 때문에 클라이언트는 DELETE request를 다시 보내도 안전하다.

만약 POST request였다면? -> 다시 보냈을 때 의도하지 않은 상황이 발생할 수 있다!

#### 멱등한 메서드를 재요청하는 중간에 외부에 의해 리소스에 변경이 생긴다면?
- 클라이언트1: GET /users/100
- 클라이언트2: PUT /users/100
- 클라이언트1: 서버의 응답이 없음 (네트워크 문제로 timeout). GET은 멱등한 메서드이므로 GET /users/100 요청을 다시 보냄 -> 클라이언트2가 중간에 리소스를 대체했기 때문에, 바뀐 리소스가 조회된다!

**멱등은 외부 요인으로 중간에 리소스가 변경되는 것 까지 고려하지는 않는다.**


## 캐시 가능 (Cacheable methods)
- 응답 결과 리소스를 캐시해서 사용해도 되는가?
	- ex) 웹 브라우저가 서버에 용량이 매우 큰 이미지를 요청한 경우, 웹 브라우저가 해당 이미지를 캐싱하면 더 효율적임 (혹은 캐시 서버 등에도 캐싱 가능)
- GET, HEAD, POST, PATCH는 스펙 상 cachable 하다.
- 하지만 실제로는 GET, HEAD 정도만 캐시로 사용한다.
	- 캐싱을 위해서는 cache key가 필요한데, POST, PATCH는 본문 내용까지 cache key로 고려해야 함. 따라서 구현이 어렵다.
	- GET, HEAD는 요청 URL만 cache key로 사용하면 되므로 구현이 어렵지 않다.