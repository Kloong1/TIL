# 중간 정리

지금까지의 흐름을 정리해보자.

1. 새로운 할인 정책 개발
2. 새로운 할인 정책 적용과 문제점
3. 관심사의 분리
4. AppConfig 리팩터링
5. 새로운 구조와 할인 정책 적용

## 1. 새로운 할인 정책 개발
다형성 덕분에 새로운 정률 할인 정책 코드를 추가로 개발하는 것 자체는 아무 문제가 없었다. 인터페이스를 새롭게 구현하면 되기 때문.

## 2. 새로운 할인 정책 적용과 문제점
새로 개발한 정률 할인 정책을 적용하려고 해보니, 클라이언트 코드인 주문 서비스 구현체도 함께 변경해야했다! -> **OCP 위반**

주문 서비스 클라이언트가 인터페이스인 DiscountPolicy 뿐만 아니라, 구체 클래스인 FixDiscountPolicy 도 함께 의존했기 때문이다. -> **DIP 위반**

## 3. 관심사의 분리
기존에는 클라이언트가 의존하는 서버 구현 객체를 직접 생성한 뒤 로직을 실행했다. 자신이 반드시 해야 할 역할 외에 추가로 일을 하고 있다! 비유를 하면 남자 주인공 배우가 공연도 하고, 동시에 여자 주인공도 직접 초빙하는 다양한 책임을 가지고 있는 상황이다.

따라서 공연을 구성하고, 담당 배우를 섭외하고, 지정하는 책임을 담당하는 별도의 공연 기획자가 필요하다.  
**-> 공연 기획자인 AppConfig의 등장**

AppConfig는 애플리케이션의 전체 동작 방식을 구성(Configuration)하기 위해, 구현 객체를 생성하고 연결하는 책임을 갖고 있다.

이제부터 클라이언트 객체는 자신의 역할을 실행하는 것만 집중하면 된다. 즉 권한이 줄어든 동시에, 책임이 명확해졌다.

## 4. AppConfig 리팩터링
AppConfig의 코드를 봤을 때, 역할과 구현이 명확하게 분리되어서 보여지게끔 리팩터링을 하는 것이 좋다. 중복을 제거하고, 역할이 잘 드러나게 만들자.

## 5. 새로운 구조와 할인 정책 적용
정액 할인 정책을 정률 할인 정책으로 변경해 보자.

AppConfig의 등장으로 애플리케이션이 크게 사용 영역과, 객체를 생성하고 구성(Configuration)하는
영역으로 분리되었다.

할인 정책을 변경해도 사용 영역을 변경할 필요 없이 AppConfig가 있는 구성 영역만 변경하면 된다. 즉 클라이언트 코드인 주문 서비스 코드를 변경할 핋요가 없다.



