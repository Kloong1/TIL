# 회원 관리 예제 프로젝트 1 - 회원 도메인과 리포지토리 개발 및 테스트

가장 단순한 형태의 예제를 구현해 보는 것을 통해 전반적인 Spring 개발 과정과 동작 방식을 알아보자.

## 1. 비즈니스 요구사항 정리

#### 데이터
 1. 회원 ID
 2. 회원 이름

#### 기능
 1. 회원 등록
 2. 회원 조회

#### 가상의 시나리오
아직 어떤 DB를 쓸 것인지 선정되지 않음 (RDBMS를 쓸 것인지, NoSQL 쓸 것인지 등...)

#### 일반적인 웹 어플리케이션 계층 구조
![](Pasted%20image%2020220301221607.png)

 1. 컨트롤러: 웹 MVC의 컨트롤러 역할
 2. 서비스: 핵심 비즈니스 로직 구현
 3. 도메인: 비즈니스 도메인 객체 (회원, 주문, 쿠폰 등... 주로 DB에 저장하고 관리됨)
 4. 리포지토리: DB에 접근, 도메인 객체를 DB에 저장하고 관리


#### 클래스 의존 관계
![](Pasted%20image%2020220301222141.png)
 - 아직 DB가 선정되지 않았다는 가상의 시나리오 (DB는 RDB, NoSQL 등 다양한 DB를 고민 중인 상황으로 가정). 따라서 리포지토리를 인터페이스로 구현해서, 추후에 DB가 선정되었을 때에 클래스를 변경할 수 있도록 설계한다.
 - 일단 개발을 하긴 해야하기 때문에, 초기 개발 단계에서는 구현체로 가벼운 메모리 기반의 데이터 저장소를 사용함.


## 2. 회원 도메인과 리포지토리 만들기

#### 디렉토리 및 소스 파일 구조
![](스크린샷%202022-03-01%20오후%2010.44.49.png)

#### Member.java
![](스크린샷%202022-03-01%20오후%2011.02.14.png)

#### MemberRepository.java
![](스크린샷%202022-03-01%20오후%2011.02.49.png)
interface로 구현했다.

#### MemoryMemberRepository.java
![](스크린샷%202022-03-01%20오후%2011.03.36.png)
MemberRepository interface를 implements 했다.

## 3. 회원 리포지토리 테스트 케이스 작성

개발한 기능이 정상 동작하는지 테스트 하기 위해, main 메서드를 통해 개발한 기능을 실행하거나, 웹 애플리케이션의 컨트롤러를 통해서 해당 기능을 실행할 수 있다.

하지만 이러한 방법은 준비하고 실행하는데 오래 걸리고, 반복 실행하기 어려우며, 여러 테스트를 한번에 실행하기 어렵다는 단점이 있다.

Java에서는 JUnit이라는 프레임워크로 테스트를 실행함으로써 이런 문제를 해결한다.

#### 회원 리포지토리 메모리 구현체 테스트

`src/test/java` 하위 폴더에 작성한다.
![](스크린샷%202022-03-02%20오전%2012.20.46.png)
일반적으로 소스 코드와 동일한 패키지 구조로 테스트 코드를 작성한다. 또 테스트 코드의 파일 이름은 `<소스 코드 파일 이름> + Test` 로 한다.

#### MemoryMemberRepositoryTest.java
![](스크린샷%202022-03-02%20오전%2012.15.34.png)
![](스크린샷%202022-03-02%20오전%2012.15.49.png)

#### Test method와 @Test annotation
Test method를 작성하는 법은 간단하다. 따로 main method를 작성할 필요 없이, 클래스를 작성하고 각 테스트 method 위에 `@Test` annotation을 붙여준다. 테스트 method의 이름은 일반적으로 테스트를 할 클래스의 method 이름과 동일하게 짓는다. 혹은 가독성과 직관성을 위해서 테스트 method 이름을 한글로 짓기도 한다.

테스트 method는 method 별로 실행이 가능하다. IntelliJ에서 각 method 선언부 좌측에 나타나는 초록색 화살표를 클릭하면 된다.

#### 모든 test method 한 번에 실행시키기
모든 테스트 method를 한번에 실행시키는 것도 가능하다. IntelliJ에서 클래스 선언부 좌측에 나타나는 초록색 화살표를 클릭하면 된다.

이 때 주의할 점은, 모든 테스트 method를 실행 시키는 경우 테스트 method의 실행 순서는 보장되지 않는다는 것이다. 따라서 이전 테스트 method의 실행 결과가 다음 테스트 method의 실행 결과에 영향을 줄 수 있다.

이를 해결하기 위해, 가장 먼저 테스트 method를 작성할 때는 각 method가 다른 테스트 method의 실행 결과에 의존하지 않도록 코드를 작성해야 한다.

#### @AfterEach annotation
테스트 method의 실행 순서 문제를 해결하는 가장 확실한 방법은 각 테스트 method 실행이 끝난 후 초기화 작업을 해주는 것이다. 이는 `@AfterEach` annotation을 붙인 method를 통해 쉽게 가능하다. 이 annotation이 붙은 method는 각 테스트 method가 실행 된 후 자동으로 실행된다. 이 method에 초기화 코드를 넣어주면 된다.

#### Assertions
`org.assertj.core.api.Assertions` 패키지나 `org.junit.jupiter.api.Assertions` 패키지에 있는 assert 관련 method를 사용하면, 테스트 결과를 loging하고 결과를 확인하는 작업을 할 필요가 없다. 해당 method들로 테스트를 하는 경우, 통과하지 못하면 다음 코드가 실행되지 않고 exception이 발생한다.

실무에서는 이를 활용해서 테스트에 통과하지 못하면 아예 빌드되지 않게끔 만들어 둔다고 한다.