# HTTP 상태 코드 3xx

## 3xx (Redirection)
요청을 완료하기 위해 유저 에이전트(클라이언트의 프로그램. 주로 웹 브라우저)의 추가적인 조치가 필요하다는 의미.

### Redirection의 이해
웹 브라우저는 3xx 코드 응답 메시지의 헤더에 Location 헤더가 있으면, Location의 URI로 자동 이동한다. **이 동작을 Redirect라고 한다.**

##### Redirection 예시 - 리소스의 URI가 바뀌었는데 바뀌기 전 리소스로 요청이 온 경우
![](스크린샷%202022-04-21%20오전%2012.53.28.png)

301 Moved Permanently 코드로 URI가 변경되었다는 것을 클라이언트에게 알린다. 또 바뀐 URI를 Location 헤더의 값으로 함께 보낸다.

웹 브라우저는 Location의 URI로 자동 redirect를 한다.
- Location의 URI로 GET request를 보낸다.

### Redirection의 종류 3가지

#### 영구 리다이렉션
- 특정 리소스의 URI가 영구적으로 이동한 경우.'
	- 예) /members -> /users, /event -> /new-event
- 기존의 URI를 사용하면 안된다.
	- 검색 엔진 등에서도 서버의 응답 메시지를 통해 해당 변경을 인지하고 URI를 변경한다.

다음 상태 코드 2가지로 표현할 수 있다.
- **301 Moved Permanently**
	- 리다이렉트시 요청 메서드가 GET으로 변할 수 있고, 메시지 본문도 제거될 수 있다 (대부분의 경우 변하고, 제거된다)
- **308 Permanent Redirect**
	- 301과 기능은 같다.
	- 리다이렉트시 요청 메서드와 본문을 유지한다. 즉 처음 POST 요청이 리다이렉트 된 경우 리다이렉트도 POST 유지

##### 301 Moved Permanently 예시
![](스크린샷%202022-04-21%20오전%201.23.04.png)

서버의 301 응답을 받고 웹 브라우저가 자동 리다이렉트를 한다. 이 때 URI를 새로운 URI로 변경하고, HTTP 메서드를 GET으로 바꿔서 요청을 보낸다. 또 메시지 바디를 제거한다 (항상 GET으로 바뀌는 것도 아니고, 반드시 바디를 제거하는 것도 아니다. 하지만 대부분 그렇게 구현되어있다).

즉 GET으로 새로운 URI에 요청을 보내는 것이기 때문에 새로운 페이지를 받게 된다. 따라서 클라이언트는 기존에 시도했던 요청(위 예제에서는 POST 요청)을 처음부터 다시 보내야 한다.

##### 308 Permanent Redirect 예시
![](스크린샷%202022-04-21%20오전%201.27.18.png)

서버가 308 코드로 웹 브라우저가 리다이렉트를 하게 만든다. 그러나 301과 다르게 HTTP 메서드와 메시지 바디를 그대로 유지한 채로 URI만 바꿔서 요청을 보낸다.

따라서 301 코드로 인한 리다이렉트에서의 문제 - 기존의 요청을 다시 보내야 한다는 문제 - 를 해결할 수 있다.

하지만 실무에서는 308보다는 301을 많이 쓸 수밖에 없다. URI가 바뀌면 요청 시 보내야 하는 데이터도 바뀌는 경우가 대부분이기 때문이다.


#### 일시적인 리다이렉션
- 리소스의 URI가 일시적으로 변경되는 경우.
	- 추후에 다시 기존의 URI로 돌아올 수도 있고, 또 다른 새로운 URI로 변경될 수도 있다.
	- ex) 주문 완료 후 주문 내역 화면으로 이동
- 따라서 검색 엔진 등에서 URI를 변경하면 안된다.

다음 상태코드로 표현 가능하다. 기능은 전부 동일하다 약간씩 다른 점이 존재한다.
- **302 Found**
	- 리다이렉트시 요청 메서드가 GET으로 변할 수 있고, 본문이 제거될 수 있다 (대부분의 경우 변하고 제거된다).
- **307 Temporary Redirect**
	- 302와 기능은 같다.
	- 리다이렉트시 요청 메서드와 본문을 반드시 유지해야 한다.
- **303 See Other**
	- 302와 기능은 같다.
	- 리다이렉트 시 요청 메서드가 **반드시 GET으로 변경된다** (302에 강제성을 부여한 경우)

302 같은 경우 GET으로 메서드가 변할 수 있다는 모호성이 존재한다. 하지만 과거 대부분의 경우 리다이렉트 시 GET으로 메서드를 변경해서 다시 요청을 보냈기 때문에 현재도 그렇게 구현한다. 만약 이런 모호성을 제거해야 하는 경우가 있다면 303이나 307로 사용해서 메서드 변경 여부를 강제할 수 있다.

하지만 실제로는 리다이렉트가 필요하면 302를 그냥 쓰고, GET으로 바꿔서 요청하는 경우가 대부분이다.

#### 일시적인 리다이렉션 예시 - PRG (Post/Redirect/Get)
실무에서 일시적인 리다이렉션을 적용하는 대표적인 예시로 PRG를 들 수 있다.

만약 POST로 상품 주문 요청을 보낸 뒤 웹 브라우저를 새로고침한다면?
- 새로고침을 한다는 것은 다시 요청을 보낸다는 것이다.
- 즉 중복 주문 요청의 위험성이 존재한다.

**이런 문제를 해결하기 위해 PRG를 적용할 수 있다.**

##### PRG 적용 전 예시
![](스크린샷%202022-04-21%20오전%201.44.45.png)

- 서버가 응답 코드로 200 OK를 보냈다.
- 사용자가 실수로 새로고침을 눌렀고, POST 요청이 한번 더 보내져서 중복 주문이 되어버렸다!

물론 실무에서는 중복 주문을 막기 위해 서버에서 미리 예방을 해놓긴 한다.

아무튼 이런 문제를 해결하기 위해 PRG를 적용해보자.
- POST로 주문 후에, GET 요청을 통해서 리다이렉트해서 주문 결과 화면으로 이동해버리자.
- 클라이언트가 새로고침 해도, 주문 결과 화면을 계속 요청하게 되는 셈이다.
- 중복 주문의 위험이 사라진다!

##### PRG 적용 후 예시
![](스크린샷%202022-04-21%20오전%201.47.45.png)

- 서버가 응답 코드로 200 OK가 아닌 302 Found를 보냈다 (303 See Other로 GET 요청을 강제해도 된다)
- 302 코드를 확인한 클라이언트는 Location의 URI로 GET 요청을 보내서 리다이렉트 한다.
- 서버는 GET 요청을 처리해서 주문 결과 페이지를 응답으로 보내준다.
- 클라이언트는 새로고침을 해도 주문 결과 페이지를 GET으로 계속 요청하게 된다.
- 중복 주문의 위험이 사라졌다.

#### 일시적인 리다이렉션 정리
- 302 Found -> GET으로 변할 수 있음
- 307 Temporary Redirect -> 메서드가 변하면 안됨
- 303 See Other -> 메서드가 GET으로 변경 되어야 함.

- 역사
	- 처음 302 스펙의 의도는 HTTP 메서드를 유지하는 것
	- 그런데 웹 브라우저들이 대부분 GET으로 바꾸어버림 (일부는 다르게 동작)
	- 그래서 모호한 302를 대신하는 명확한 307, 303이 등장함(301 대응으로 308도 등장)
- **그러나 현실은...**
	- 메서드 변경 여부가 명확한 307, 303을 권장하지만 현실적으로 이미 많은 애플리케이션 라이브러리들이 302를 기본값으로 사용
	- **자동 리다이렉션시에 GET 메서드로 변해도 되면 그냥 302를 사용해도 큰 문제 없음**

##### 특수 리다이렉션
요청 결과 대신 캐시를 사용하는 경우

- **304 Not Modified**
	- 캐시를 목적으로 사용된다.
	- 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이언트는 로컬 PC에 저장된 캐시를 재사용한다 -> **캐시로 리다이렉트 한다.**
	- 304 응답은 응답에 메시지 바디를 포함하면 안된다. (로컬 캐시를 사용해야 하므로)
	- 조건부 GET, HEAD 요청 시 사용
