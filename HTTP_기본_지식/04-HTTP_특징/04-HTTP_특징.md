# HTTP 기본

## HTTP (HyperText Transfer Protocol)
- HTML 문서같은 Hypertext를 보내기 위해 고안된 HTTP
- 현재는 HTML, Text 외에도 **거의 모든 형태의 데이터를 전송 가능하다!**
- **서버간에 데이터를 주고 받을 때도 대부분 HTTP를 사용한다.**


## HTTP 역사
- HTTP/0.9 (1991년): GET 메서드만 지원, HTTP 헤더X
- HTTP/1.0 (1996년): 메서드, 헤더 추가
- **HTTP/1.1 (1997년): 가장 많이 사용, 우리에게 가장 중요한 버전**
	- RFC2068 (1997) -> RFC2616 (1999) -> RFC7230~7235 (2014)
- HTTP/2 (2015년): 성능 개선
- HTTP/3 (진행중): TCP 대신에 UDP 사용, 성능 개선

HTTP/1.1에 대부분의 기능이 구현되어 있다.

RFC2068부터 RFC7230~7235까지 계속해서 HTTP/1.1이 개선되어 왔다.

RFC7230 ~ 7235 이렇게 여러개인 이유는 HTTP/1.1이 하나의 큰 문서에서 여러개의 문서로 나뉘어졌기 때문. 현재는 이 스펙을 사용하기 때문에 여기에 맞춰서 개발해야한다.

현재 HTTP/1.1을 주로 사용한다.

HTTP/1.1과 HTTP/2는 TCP 기반이고, HTTP/3은 UDP 기반의 프로토콜이다. TCP의 오버헤드로 인한 성능 문제를 개선하기 위해 HTTP/3이 개발되었다.

![](스크린샷%202022-04-18%20오후%2011.02.18.png)

사진 우측에 보면 프로토콜 부분에 h3라고 쓰여있는 것을 볼 수 있다. HTTP/3를 의미한다! HTTP/2와 HTTP/3는 이미 사용되고 있다.


## HTTP 특징
### 1. 클라이언트-서버 구조
- 클라이언트는 HTTP 메시지를 통해서 서버에 요청을 보내고, 응답을 대기한다.
- 서버가 요청에 대한 결과를 만들어서 응답한다.
- Request-Response 구조

기존에는 클라이언트와 서버라는 개념이 분리되어 있지 않았다. 클라이언트가 서버 역할도 했었다고 보면 된다.

하지만 HTTP에서는 클라이언트와 서버로 분리함으로써 여러 장점이 생겼다.
- 비즈니스 로직과 데이터 등을 서버에 몰아넣는다.
- 클라이언트는 UI, 사용성 등에 집중한다.
- 이렇게 구분하는 것을 통해서 클라이언트와 서버가 독립적으로 진화할 수 있다.
	- 클라이언트는 기기, 환경 등에 맞춘 UI/UX, 사용성 관련에 집중
	- 서버는 최적화, 알고리즘, 아키텍쳐 등에 집중
	- 클라이언트와 서버가 서로 뭘 하는지 신경 쓸 필요가 없이 자기 일에만 집중 가능하기 때문에 독립적으로 진화가 가능해짐

### 2.Stateless 프로토콜

서버가 클라이언트의 상태를 보존하지 않는다.
- 장점: 서버의 확장성이 높다.
- 단점: 클라이언트가 추가 데이터를 전송해야 한다.

#### Stateful 예시 1 - 점원이 대화의 문맥을 기억하고 있다
![](스크린샷%202022-04-19%20오후%204.52.11.png)
서버가 클라이언트의 이전 상태, 문맥(context)을 보존한다.

#### Stateful 예시 2 - 대화 도중 점원이 바뀐다면?
![](스크린샷%202022-04-19%20오후%204.56.02.png)
서버가 바뀌면, 클라이언트의 이전 상태를 알 방법이 없다!

#### Stateless 예시 - 점원이 자꾸 바뀌어도 괜찮다!
![](스크린샷%202022-04-19%20오후%204.54.30.png)
고객이 점원이 알아야 할 내용을 계속 알려준다. 따라서 점원이 바뀌어도 괜찮다.

#### Stateful, Stateless 차이
- **Stateful**: 중간에 다른 점원으로 바뀌면 문맥을 잃어버린다. 점원이 중간에 바뀐다면 현재 클라이언트 상태 정보를 바뀌는 점원에게 넘겨줘야한다. 따라서 점원을 바꾸기가 쉽지가 않아진다.
- **Stateless**: 중간에 다른 점원으로 바뀌어도 상관 없다.
	- 갑자기 고객이 증가해도 점원을 대거 투입할 수 있다.
	- 즉 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다. 클라이언트가 증설한 서버 중 아무 서버에 요청을 해도 정상적인 통신이 가능하다.
	- 따라서 응답 서버를 쉽게 바꿀 수 있다. -> **무한한 서버 증설이 가능해진다!**

#### Stateful 서버 예시
![](스크린샷%202022-04-19%20오후%205.03.25.png)
서버가 클라이언트의 이전 상태를 알고 있어야 하기 때문에, 클라이언트A는 항상 서버1과 통신해야 한다.

![](스크린샷%202022-04-19%20오후%205.03.52.png)
통신 중간에 서버1이 죽으면 클라이언트A는 이전의 상태를 전부 잃어버리기 때문에, 다른 서버에 이전의 요청을 처음부터 다시 보내야 한다!

#### Stateful 서버 예시
![](스크린샷%202022-04-19%20오후%205.05.56.png)
서버가 상태를 저장하지 않는다. 따라서 클라이언트는 각 요청마다 서버가 필요한 정보를 전부 담아서 보내야 한다. 따라서 같은 서버와 계속 통신할 필요가 없다.

![](스크린샷%202022-04-19%20오후%205.06.44.png)
클라이언트가 요청에 모든 정보를 전부 담아서 보내기 때문에, 통신하는 서버만 바꾸면 정상 동작 가능하다.

#### Scale-out(수평 확장)에 유리한 Stateless
![](스크린샷%202022-04-19%20오후%205.30.09.png)

#### Stateless의 실무에서의 한계
- 데이터 전송량이 Stateful에 비해서 많을 수 밖에 없다.
- **모든 것을 Stateless로 설계할 수는 없다.**
	- ex) 로그인. 로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지해야 한다.
	- 브라우저 쿠키와 서버 세션 등을 사용해서 상태를 유지할 수 있다.
	- 서버가 죽어버리면? -> 로그인이 풀린다!
- **Stateful은 반드시 필요한 경우에만 최소한으로 사용하자.**


### 3. Connectionless (비연결성)
#### 연결을 유지하는 모델
![](스크린샷%202022-04-19%20오후%207.21.28.png)

##### 단점
- 서버-클라이언트 간의 연결을 유지하는 것 자체로 서버의 자원이 소모된다.
- 요청을 하지 않고 있는 클라이언트와의 연결도 계속 유지해야 한다.

#### 연결을 유지하지 않는 모델
![](스크린샷%202022-04-19%20오후%207.23.45.png)

클라이언트의 요청이 있을 때만 연결을 하고, 요청 처리가 끝나면 연결을 바로 종료한다. 이를 통해 서버의 자원 소모를 최소화 할 수 있다.

#### Connectionless의 특징
- 일반적으로 초 단위 이하의 빠른 속도로 응답이 가능하다.
- 1시간 동안 수천명이 서비스를 사용해도, 실제 서버에서 "동시에" 처리하는 요청은 수십개 이하로 매우 작다 (모든 사용자가 동시에 연속적으로 검색 버튼을 누른다거나 하지 않기 때문)
- 즉 웹 서비스를 제공할 때 매우 유용하다.
- 서버의 자원을 매우 효율적으로 사용할 수 있다.
- HTTP는 기본적으로 connectionless 모델이다.

#### Connectionless의 한계와 극복
- 매 요청마다 TCP 연결을 새로 맺어야 한다.
	- 3 way handshake를 반복해야한다.
	- 오버헤드가 크다.
- 웹 브라우저로 사이트를 요청하면, HTML 뿐만 아니라 자바스크립트, css, 이미지 등 많은 자원이 함께 다운로드된다.
	- 각 자원을 받을 때마다 새롭게 연결을 하면 오버헤드가 너무 크다!
- 지금은 HTTP persistence connection으로 문제를 해결햤다.
	- HTTP/2, HTTP/3에서 더 많은 최적화가 이루어졌다.

##### HTTP 초기 - 새로운 연결로 인한 오버헤드 발생
![](스크린샷%202022-04-19%20오후%207.30.59.png)

##### HTTP Persistence Connections (HTTP 지속 연결)
![](스크린샷%202022-04-19%20오후%207.31.56.png)

한 번 연결이 되면 일정 시간 동안 연결을 유지한다 (시간, 방식은 서버마다 다를 수 있다). 따라서 반복적인 연결로 인한 오버헤드를 최소화한다.