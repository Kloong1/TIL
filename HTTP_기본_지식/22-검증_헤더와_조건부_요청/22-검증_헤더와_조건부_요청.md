# 검증 헤더와 조건부 요청

## 캐시 시간 초과
캐시 유효 시간이 초과해서 서버에 원본 데이터를 다시 요청하면 다음 두 가지 상황이 나타난다.
- 서버에서 기존 데이터를 변경함
	- 변경한 데이터를 서버로부터 다운로드 받아야 함
- 서버에서 기존 데이터를 변경하지 않음
	- 캐시를 그대로 사용하면 되지 않을까...?
	- **단 클라이언트의 데이터와 서버의 데이터가 같다는 것을 확인할 방법이 필요하다!**

![](스크린샷%202022-04-26%20오후%202.43.20.png)


## 검증 헤더
##### 첫 번째 요청 - 검증 헤더 적용
![](스크린샷%202022-04-26%20오후%202.45.01.png)
- Last-Modified 헤더를 사용해서 해당 데이터의 최종 수정일을 함께 전달한다.

##### 응답을 캐시에 저장 - 최종 수정일과 유효 시간을 함께 저장한다
![](스크린샷%202022-04-26%20오후%202.45.42.png)
- 캐시에 데이터를 저장할 때 유효 기간과 최종 수정일을 함께 저장한다.

##### 캐시가 만료된 경우 - 서버에 최종 수정일과 함께 요청을 보냄
![](스크린샷%202022-04-26%20오후%202.47.29.png)
- 캐시가 만료된 경우, 서버에 해당 데이터를 재요청해야한다.
- 이 때 최종 수정일 (Last-modified) 정보가 해당 캐시에 있는 경우, **조건부 요청을 보낸다.**
- if-modified-since 헤더에 해당 데이터의 최종 수정일에 대한 정보를 담아서 요청을 한다.

##### 클라이언트의 캐시 데이터와 서버의 데이터가 동일한 경우
![](스크린샷%202022-04-26%20오후%202.48.34.png)
- 서버가 if-modified-since 헤더가 있는 요청을 받는다.
- 해당 헤더의 최종 수정일과 요청받은 데이터의 최종 수정일을 비교해서 **캐시를 검증할 수 있다.**
- **두 날짜가 같은 경우 기존 캐시를 그대로 사용할 수 있다!**

##### 304 Not Modified로 캐시를 그대로 사용할 수 있다는 사실을 알려줌
![](스크린샷%202022-04-26%20오후%202.51.52.png)
- 서버는 HTTP body가 없는 304 응답을 보낸다.
- 캐시를 그대로 사용해도 된다는 정보를 담은 헤더만 보내므로, 네트워크 사용량을 줄일 수 있다.

##### 캐시의 유효 기간을 갱신 후 캐시 사용
![](스크린샷%202022-04-26%20오후%202.53.28.png)
![](스크린샷%202022-04-26%20오후%202.54.40.png)
- 클라이언트는 304 응답을 통해 캐시를 그대로 사용할 수 있다는 사실 (서버의 데이터와 캐시 데이터가 동일하다는 사실)을 알게 되었다.
- 캐시의 유효기간을 갱신하고 캐시를 사용한다.


## 검증 헤더와 조건부 요청
- **Last-Modified**: 검증 헤더. 데이터의 최종 수정일을 응답과 함께 넘겨준다.
- **if-modified-since**: 조건부 요청 헤더. 캐시 데이터와 함께 저장한 Last-Modified 값을 요청과 함께 보낸다.
	- 서버는 이 값을 통해서 캐시와 서버의 데이터가 동일한지 검증할 수 있다.
- 캐시 유효 시간을 초과해서 캐시가 만료되어도, **서버의 데이터와 캐시 데이터가 동일하다면 해당 데이터를 다시 다운로드 받을 필요가 없다.**
	- 서버는 body 없이 헤더만 있는 304 Not Modified 응답을 보낸다.
	- 클라이언트는 서버가 보낸 응답의 헤더로 캐시의 메타 정보를 갱신한다.
		- 유효 기간 등을 갱신한다. 
	- 클라이언트는 캐시를 재활용할 수 있다.
- 결과적으로 네트워크 다운로드가 발생하지만, **용량이 상대적으로 매우 작은 헤더 정보만 다운로드 받으면 된다.**


## ETag와 If-None-Match
- Last-Modified 검증 헤더 대신 ETag를 사용할 수 있다.
- if-modified-since를 사용한 조건부 요청 대신 if-none-match를 사용한 조건부 요청을 할 수 있다.
- Last-Modified와 if-modified-since가 함께 사용된다.
- ETag와 if-none-match가 함께 사용된다.

#### Last-Modified와 If-Modified-Since 예시
If-Modified-Since 이후에 데이터가 변경되었으면?

- 데이터가 변경되지 않은 경우
	- 캐시: 2020년 11월 10일 10:00:00 vs 서버: 2020년 11월 10일 10:00:00
	- 304 Not Modified, 헤더 데이터만 전송 (BODY 미포함)
	- 캐시 메타 데이터 갱신 후 재사용
	- 전송 용량 0.1M (헤더 0.1M, 바디 1.0M)
- 데이터가 변경된 경우
	- 캐시: 2020년 11월 10일 10:00:00 vs 서버: 2020년 11월 10일 11:00:00
	- 200 OK, 바디에 모든 데이터를 담아서 전송 (BODY 포함)
	- 전송 용량 1.1M (헤더 0.1M, 바디 1.0M)

#### Last-Modified와 If-Modified-Since 단점
- 1초 미만(0.x초) 단위로 캐시 조정이 불가능
- 데이터가 아닌 날짜 기반의 로직을 사용하기 때문에 불필요한 캐시 갱신이 발생할 가능성
	- 데이터를 수정해서 수정 날짜는 갱신되었지만, 수정 결과가 기존 데이터와 동일한 경우
		- 예) A -> B로 수정 후 다시 B -> A 로 수정
		- 예) 데이터가 잠시 이동되었다가 다시 기존 위치로 돌아온 경우
- 서버에서 별도의 캐시 로직을 사용하고 싶은 경우
	- 예) 스페이스나 주석처럼 크게 영향이 없는 변경의 경우에는 캐시를 유지하고 싶다!

### ETag와 If-None-Match
- ETag: Entity Tag
- 캐시용 데이터에 (날짜가 아닌) 임의의 고유한 버전 이름을 붙여둔다.
	- 예) ETag: "v1.0", ETag: "a2jiodwjekjl3"
- 데이터가 변경되면 버전 이름을 변경한다.
	- 데이터를 Hashing해서 버전 이름으로 사용할 수 있다.
	- Hashing을 쓰면 데이터의 수정 결과가 기존 데이터와 동일한 경우, ETag가 변하지 않는다.
- 클라이언트 캐시의 ETag와 서버 데이터의 ETag가 같으면 캐시를 유지하고, 다르면 다시 받으면 된다!

![](스크린샷%202022-04-26%20오후%203.20.53.png)
![](스크린샷%202022-04-26%20오후%203.21.01.png)
![](스크린샷%202022-04-26%20오후%203.21.15.png)
![](스크린샷%202022-04-26%20오후%203.21.36.png)

### ETag, If-None-Match 정리

- 클라이언트 캐시의 ETag와 서버 데이터의 ETag가 같으면 캐시를 유지하고, 다르면 다시 받는다.
- **캐시 제어 로직을 서버에서 완전히 관리한다!**
	- 클라이언트는 단순히 캐시에 저장하고 있는 ETag 값을 서버에 전달하기만 한다.
	- 클라이언트는 서버의 캐시 관리 로직을 전혀 알 수 없다.
	- 서버가 ETag를 갱신하지 않고 있다가, 어플리케이션 배포 주기에 맞추어 ETag를 모두 갱신하는 등의 방식으로 사용할 수 있다.