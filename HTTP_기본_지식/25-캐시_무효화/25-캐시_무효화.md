# 캐시 무효화
반드시 캐싱이 되어서는 안되는 데이터도 존재한다. 클라이언트가 반드시 가장 최근에 갱신된 데이터를 봐야하는 경우 (사용자 통장 잔고 등)가 있다.

그럴 때는 서버에서 캐시를 확실히 무효화 할 방법이 필요하다. 웹 브라우저가 자기 맘대로 캐싱을 해버릴 수가 있기 때문에, 그런 경우를 원천 봉쇄해야 한다.

확실한 캐시 무효화를 위해 다음 헤더를 **전부 사용해야 한다.**

- **Cache-Control: no-cache, no-store, must-revalidate**
- **Pragma: no-cache (HTTP/1.0 하위 호환을 위함)**


## 확실한 캐시 무효화를 위한 헤더
- **Cache-Control: no-cache**
	- 데이터는 캐시해도 되지만, 항상 **origin 서버**에 검증하고 사용
- **Cache-Control: no-store**
	- 데이터에 민감한 정보가 있으므로 저장하면 안됨 (메모리에서 사용하고 최대한 빨리 삭제)
- **Cache-Control: must-revalidate**
	- 캐시 만료후 최초 조회시 **origin 서버에 검증**해야 함
	- **origin 서버 접근 실패시 반드시 오류가 발생해야 함**
		- 504(Gateway Timeout)
	- must-revalidate는 캐시 유효 시간이라면 캐시를 사용함
- **Pragma: no-cache**
	- HTTP 1.0 하위 호환을 위해 사용하는 헤더


## 왜 이 헤더들을 "전부" 사용해야 하는가?
##### no-cache만 사용하는 경우
![](스크린샷%202022-04-26%20오후%204.51.50.png)
- no-cache로 설정된 캐시이므로, 클라이언트는 항상 origin 서버에 검증을 요청한다.
- 프록시 캐시 서버 역시 no-cache 요청이므로 자신이 처리하지 않고 origin 서버에 검증을 한다.

##### no-cache만 사용하는 경우 - origin 서버와의 연결 실패 상황
![](스크린샷%202022-04-26%20오후%204.53.35.png)
- origin 서버에 접속이 불가능 한 상황
- no-cache임에도 불구하고, 프록시 서버 설정에 따라 origin 서버의 검증 없이 캐시 데이터를 반환하는 경우가 있음
- 클라이언트 입장에서는 origin 서버의 상황을 알 수 없음. 프록시 서버가 정상적으로 데이터를 넘겨줬으므로 클라이언트는 해당 데이터가 origin 서버로부터 검증된 데이터라고 생각할 수 밖에 없다!

##### must-revalidate를 사용하는 경우
![](스크린샷%202022-04-26%20오후%204.56.41.png)
- must-revalidate 헤더에 의해 **origin 서버에 검증할 수 없는 경우 항상 오류가 발생해야 한다!**
- 프록시 서버는 클라이언트에게 캐시 데이터를 넘겨준다거나 하는 작업 없이, 504 Gateway Timeout 응답을 한다.
- origin 서버에 검증이 불가능하다고 해서 캐싱된 사용자 통장 잔고를 보여준다면 문제가 생길 수 있다. 이런 경우는 오류를 발생시켜야 한다.

## 정리
### Cache-Control: no-cache, no-store, must-revalidate
- **no-store로 웹 브라우저가 캐싱을 하지 못하게 한다.**
- 그래도 캐싱을 한다면 **no-cache로 항상 origin 서버에 검증을 하게 한다.**
- 검증을 할 때 origin 서버에 접근이 불가능하다고 해서 **proxy 서버가 맘대로 캐시 데이터를 넘기지 못하게 하기 위해 must-revalidate를 사용한다.**

### Pragma: no-cache
- HTTP 1.0 하위 호환을 위해 사용해야한다.